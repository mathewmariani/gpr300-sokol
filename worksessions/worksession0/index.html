<!DOCTYPE html><html lang="en" data-bs-theme="dark"> <head><base href="/gpr300-sokol/"><!-- global --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" type="image/png" href="/favicon.png"><link rel="sitemap" href="/sitemap-index.xml"><meta name="generator" content="Astro v5.15.1"><!-- bootstrap-theme --><link href="https://unpkg.com/@highlightjs/cdn-assets@11.7.0/styles/github-dark.min.css" rel="stylesheet"><!-- primary --><title>GPR-300</title><meta name="title" content="GPR-300"><meta name="description" content><!-- open graph --><meta property="og:type" content="website"><meta property="og:url" content="https://www.mathewmariani.com/gpr300-sokol/worksessions/worksession0/"><meta property="og:title" content="GPR-300"><meta property="og:description" content><!-- <meta property="og:image" content={new URL(image, Astro.url)} /> --><!-- twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://www.mathewmariani.com/gpr300-sokol/worksessions/worksession0/"><meta property="twitter:title" content="GPR-300"><meta property="twitter:description" content><!-- <meta property="twitter:image" content={new URL(image, Astro.url)} /> --><link rel="stylesheet" href="/gpr300-sokol/_astro/_slug_.DuSM1kai.css">
<style>.demo[data-astro-cid-3cfzgy2g]{margin-right:auto;margin-left:auto;border:0;width:800px;height:600px;overflow:hidden;display:block;image-rendering:optimizeSpeed;image-rendering:-moz-crisp-edges;image-rendering:-o-crisp-edges;image-rendering:-webkit-optimize-contrast;image-rendering:optimize-contrast;image-rendering:crisp-edges;image-rendering:pixelated;-ms-interpolation-mode:nearest-neighbor}
</style></head> <body class="container" id="top"> <main> <article>  <h1>Work Session 0</h1> <div class="highlight"></div> <p class="lead">Physically Based Rendering (PBR)</p> <canvas class="demo" id="canvas" oncontextmenu="event.preventDefault()" data-astro-cid-3cfzgy2g></canvas> <script type="text/javascript">
  var Module = {
    preRun: [],
    postRun: [],
    print: (function () {
      return function (text) {
        text = Array.prototype.slice.call(arguments).join(" ");
        console.log(text);
      };
    })(),
    printErr: function (text) {
      text = Array.prototype.slice.call(arguments).join(" ");
      console.error(text);
    },
    canvas: (function () {
      var canvas = document.getElementById("canvas");
      canvas.addEventListener(
        "webglcontextlost",
        function (e) {
          alert("FIXME: WebGL context lost, please reload the page");
          e.preventDefault();
        },
        false,
      );
      return canvas;
    })(),
    setStatus: function (text) {},
    monitorRunDependencies: function (left) {},
  };
  window.onerror = function (event) {
    console.log("onerror: " + event.message);
  };
</script> <script type="text/javascript" src="demos/worksession0.js" async></script>  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
<h4 id="goal">Goal</h4>
<p>This worksessiong should be built off of assignment 3. That would mean we are creating a deferred PBR rendering pipeline.</p>
<p>This worksession involves converting mathematical equations into a shader program for use in the graphics pipeline. You will be provided with equations, and your task is to express them in GLSL (OpenGL Shading Language) code. This exercise aims to develop your skills in translating equations into a fragment shader for visualization on the GPU.</p>
<p>Through this practical application, you’ll gain hands-on experience in shader programming, connecting mathematical formulations with visual outputs.</p>
<h4 id="requirements">Requirements</h4>
<p>There isn’t a list of traits that define what a “Physically Based Renderer” is compared to a regular lighting model is, but we will define some common traits that we will implement.</p>
<ol>
<li>Energy Conservation
<ul>
<li>The energy going in must not exceed the energy coming out.</li>
</ul>
</li>
<li>Microfacet Model
<ul>
<li>Surfaces are made of microscopic faces that perfectly reflect light.</li>
</ul>
</li>
<li>Fresnel Effect
<ul>
<li>The lower the viewing angle on surface is the better the reflection is.</li>
</ul>
</li>
<li>Authored Materials
<ul>
<li>Using textures gives us per-fragment control over how each specific surface point should react to light.</li>
</ul>
</li>
</ol>
<p>In your own research you may notice that not all tutorials follow these traits, yet they are still considered to be PBR. You may also find that not all resources use the same functions or models, this is normal.</p>
<h4 id="lighting-equation">Lighting Equation</h4>
<p>The lighting equation, sometimes referred to as the “rendering equation”, is described to as follows:</p>
<span>
$$
L_o(x, V) = L_e(x, V) + \int{f_r(x, L, V)L_i(x, V)(L \cdot N)}dL
$$
</span>
<p>Since we won’t be fully simulating <em><em>all possible lights within a hemisphere</em></em>. We’re going to simplify the equation to use a fixed number of lights, and I’ll give these variables names so we can more easily reference them later.</p>
<span>
$$
\underbrace{L_o(x, V)}_{\text{outgoing}} = \underbrace{L_e(x, V)}_{\text{emitted}} + \sum{\underbrace{f_r(x, L_n, V)}_{\text{BDRF}} \underbrace{L_i(x, L_n)}_{\text{incoming}} \underbrace{(L_n \cdot N)}_{\text{LdotN}}}
$$
</span>
<span>
$$
\begin{cases}
x = \text{fragment position}, \\[2ex]
V = \text{view vector}, \\[2ex]
L_n = \text{current light vector}, \\[2ex]
\end{cases}
$$
</span>
<details>
    <summary>/* code spoilers */</summary>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="glsl"><code><span class="line"><span style="color:#6A737D">// material properties</span></span>
<span class="line"><span style="color:#F97583">uniform</span><span style="color:#F97583"> float</span><span style="color:#E1E4E8"> metallic;</span></span>
<span class="line"><span style="color:#F97583">uniform</span><span style="color:#F97583"> float</span><span style="color:#E1E4E8"> roughness;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// cached dot products</span></span>
<span class="line"><span style="color:#F97583">float</span><span style="color:#E1E4E8"> NdotH;</span></span>
<span class="line"><span style="color:#F97583">float</span><span style="color:#E1E4E8"> NdotV;</span></span>
<span class="line"><span style="color:#F97583">float</span><span style="color:#E1E4E8"> NdotL;</span></span>
<span class="line"><span style="color:#F97583">float</span><span style="color:#E1E4E8"> VdotH;</span></span>
<span class="line"><span style="color:#F97583">float</span><span style="color:#E1E4E8"> VdotN;</span></span>
<span class="line"><span style="color:#F97583">float</span><span style="color:#E1E4E8"> LdotN;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// Rendering equation</span></span>
<span class="line"><span style="color:#6A737D">// N: normal</span></span>
<span class="line"><span style="color:#6A737D">// V: view vector</span></span>
<span class="line"><span style="color:#6A737D">// L: light vector</span></span>
<span class="line"><span style="color:#6A737D">// H: halfway vector</span></span>
<span class="line"><span style="color:#F97583">void</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">()</span></span>
<span class="line"><span style="color:#E1E4E8">{</span></span>
<span class="line"><span style="color:#6A737D">    // normalize all vectors</span></span>
<span class="line"><span style="color:#E1E4E8">    vec3 N </span><span style="color:#F97583">=</span><span style="color:#B392F0"> normalize</span><span style="color:#E1E4E8">(vs_normal);</span></span>
<span class="line"><span style="color:#E1E4E8">    vec3 V </span><span style="color:#F97583">=</span><span style="color:#B392F0"> normalize</span><span style="color:#E1E4E8">(camera_position);</span></span>
<span class="line"><span style="color:#E1E4E8">    vec3 L </span><span style="color:#F97583">=</span><span style="color:#B392F0"> normalize</span><span style="color:#E1E4E8">(light.position);</span></span>
<span class="line"><span style="color:#E1E4E8">    vec3 H </span><span style="color:#F97583">=</span><span style="color:#B392F0"> normalize</span><span style="color:#E1E4E8">(V </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> L);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">    // pre-compute all dot products</span></span>
<span class="line"><span style="color:#E1E4E8">    NdotH </span><span style="color:#F97583">=</span><span style="color:#B392F0"> max</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">dot</span><span style="color:#E1E4E8">(N, H), </span><span style="color:#79B8FF">0.0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    NdotV </span><span style="color:#F97583">=</span><span style="color:#B392F0"> max</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">dot</span><span style="color:#E1E4E8">(N, V), </span><span style="color:#79B8FF">0.0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    NdotL </span><span style="color:#F97583">=</span><span style="color:#B392F0"> max</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">dot</span><span style="color:#E1E4E8">(N, L), </span><span style="color:#79B8FF">0.0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    VdotN </span><span style="color:#F97583">=</span><span style="color:#B392F0"> max</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">dot</span><span style="color:#E1E4E8">(V, N), </span><span style="color:#79B8FF">0.0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    VdotH </span><span style="color:#F97583">=</span><span style="color:#B392F0"> max</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">dot</span><span style="color:#E1E4E8">(V, H), </span><span style="color:#79B8FF">0.0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    LdotN </span><span style="color:#F97583">=</span><span style="color:#B392F0"> max</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">dot</span><span style="color:#E1E4E8">(L, N), </span><span style="color:#79B8FF">0.0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">    // NOTE: these are just placeholders.</span></span>
<span class="line"><span style="color:#6A737D">    // It would be appropriate to turn them into functions.</span></span>
<span class="line"><span style="color:#E1E4E8">    vec3 emitted </span><span style="color:#F97583">=</span><span style="color:#B392F0"> vec3</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0.0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    vec3 brdf </span><span style="color:#F97583">=</span><span style="color:#B392F0"> vec3</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0.0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    vec3 incoming </span><span style="color:#F97583">=</span><span style="color:#B392F0"> vec3</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0.0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    vec3 pbr </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> emited </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> (brdf </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> incoming </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> LdotN);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">    // NOTE: returning pbr as the final color isn't strictly necessary.</span></span>
<span class="line"><span style="color:#6A737D">    // At this point, or at any point really, you can styalize how you want.</span></span>
<span class="line"><span style="color:#E1E4E8">    FragColor </span><span style="color:#F97583">=</span><span style="color:#B392F0"> vec4</span><span style="color:#E1E4E8">(pbr, </span><span style="color:#79B8FF">1.0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
</details>
<h5 id="bidirectional-reflective-distribution-function-brdf">Bidirectional Reflective Distribution Function (BRDF)</h5>
<p>The first variable (or function) were going to tackle is the BRDF. This variable is relatively straight forward as we simply add our diffuse and specular lighting. Notice that ( k_d + k_s = 1 ) this is for energy conservation, no extra light is being produced.</p>
<span>
$$
BRDF = \underbrace{k_df_{lambert}}_{\text{diffuse}} + \underbrace{k_sf_{cook-torrence}}_{\text{specular}}
$$
</span>
<span>
$$
\begin{cases}
k_s=Fresnel, \\[2ex]
k_d=1-k_s,
\end{cases}
$$
</span>
<details>
    <summary>/* code spoilers */</summary>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="glsl"><code><span class="line"><span style="color:#F97583">vec3</span><span style="color:#B392F0"> BDRF</span><span style="color:#E1E4E8">()</span></span>
<span class="line"><span style="color:#E1E4E8">{</span></span>
<span class="line"><span style="color:#6A737D">    // lambertian distribution</span></span>
<span class="line"><span style="color:#E1E4E8">    vec3 lambert </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> alb </span><span style="color:#F97583">/</span><span style="color:#E1E4E8"> PI;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">    // NOTE: these are just placeholders.</span></span>
<span class="line"><span style="color:#6A737D">    // It would be appropriate to turn them into functions.</span></span>
<span class="line"><span style="color:#E1E4E8">    vec3 schlickFresnel </span><span style="color:#F97583">=</span><span style="color:#B392F0"> vec3</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">1.0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    vec3 cookTorrance </span><span style="color:#F97583">=</span><span style="color:#B392F0"> vec3</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">1.0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">    // ratio between reflection and refraction</span></span>
<span class="line"><span style="color:#6A737D">    // Ks + Kd = 1</span></span>
<span class="line"><span style="color:#E1E4E8">    vec3 Ks </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> schlickFresnel;</span></span>
<span class="line"><span style="color:#E1E4E8">    vec3 Kd </span><span style="color:#F97583">=</span><span style="color:#B392F0"> vec3</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">1.0</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">-</span><span style="color:#E1E4E8"> Ks;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">    // diffuse + specular</span></span>
<span class="line"><span style="color:#E1E4E8">    vec3 diffuseBRDF </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> (Kd </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> lambert);</span></span>
<span class="line"><span style="color:#E1E4E8">    vec3 specularBRDF </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> (Ks </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> cookTorrance);</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> diffuseBRDF </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> specularBRDF;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
</details>
<h5 id="fresnel-schlick-function">Fresnel-Schlick Function</h5>
<p>The Fresnel-Schlick function approximates reflectance variation based on the viewing angle, increasing specular reflection at grazing angles for realistic material appearance.</p>
<span>
$$
F_{\text{schlick}} = F_0+(1-F_0)(1 - (V \cdot H))^5
$$
</span>
<span>
$$
\begin{cases}
F_0 = \text{base reflectivity}, \\[2ex]
V = \text{view vector}, \\[2ex]
H = \text{half-way vector}, \\[2ex]
\end{cases}
$$
</span>
<h5 id="lambertian-distribution">Lambertian Distribution</h5>
<span>
$$
f_{\text{lambert}}=\frac{\text{albedo}}{\pi}
$$
</span>
<h5 id="cook-torrence-function">Cook-Torrence Function</h5>
<p>The Cook-Torrance function simulates light reflection by considering surface roughness, light scattering, and view dependence, producing realistic highlights and material appearance in rendering.</p>
<span>
$$
f_{\text{cook-torrence}} = \frac{DGF}{4(V \cdot N)(L_n \cdot N)}
$$
</span>
<span>
$$
\begin{cases}
D = \text{Normal Distribution Function}, \\[2ex]
G = \text{Geometry Shadowing Function}, \\[2ex]
F = \text{Fresnel Function}, \\[2ex]
V = \text{view vector}, \\[2ex]
N = \text{normal vector}, \\[2ex]
L_n = \text{current light vector}, \\[2ex]
\end{cases}
$$
</span>
<details>
    <summary>/* code spoilers */</summary>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="glsl"><code><span class="line"><span style="color:#6A737D">// V: view vector</span></span>
<span class="line"><span style="color:#6A737D">// H: half-way vector</span></span>
<span class="line"><span style="color:#6A737D">// L: light vector</span></span>
<span class="line"><span style="color:#6A737D">// N: normal</span></span>
<span class="line"><span style="color:#6A737D">// F0: base reflectivity</span></span>
<span class="line"><span style="color:#6A737D">// alpha: roughness</span></span>
<span class="line"><span style="color:#F97583">vec3</span><span style="color:#B392F0"> cookTorrence</span><span style="color:#E1E4E8">(vec3 </span><span style="color:#FFAB70">VdotH</span><span style="color:#E1E4E8">, vec3 </span><span style="color:#FFAB70">VdotN</span><span style="color:#E1E4E8">, vec3 </span><span style="color:#FFAB70">LdotN</span><span style="color:#E1E4E8">, vec3 </span><span style="color:#FFAB70">F0</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">float</span><span style="color:#FFAB70"> alpha</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">{</span></span>
<span class="line"><span style="color:#6A737D">    // D: GGX / Throwbridge-Reitz Normal Distribution Function</span></span>
<span class="line"><span style="color:#6A737D">    // G: Schlick-Beckmann Geometry Shadowing Function</span></span>
<span class="line"><span style="color:#6A737D">    // F: Fresnel-Schlick Function</span></span>
<span class="line"><span style="color:#E1E4E8">    vec3 cookTorranceNumerator </span><span style="color:#F97583">=</span><span style="color:#B392F0"> D</span><span style="color:#E1E4E8">(alpha) </span><span style="color:#F97583">*</span><span style="color:#B392F0"> G</span><span style="color:#E1E4E8">(alpha) </span><span style="color:#F97583">*</span><span style="color:#B392F0"> F</span><span style="color:#E1E4E8">(F0, VdotH);</span></span>
<span class="line"><span style="color:#F97583">    float</span><span style="color:#E1E4E8"> cookTorranceDenominator </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 4.0</span><span style="color:#F97583"> *</span><span style="color:#E1E4E8"> VdotN </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> LdotN;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">    // avoid divide by 0.</span></span>
<span class="line"><span style="color:#E1E4E8">    cookTorranceDenominator </span><span style="color:#F97583">=</span><span style="color:#B392F0"> max</span><span style="color:#E1E4E8">(cookTorranceDenominator, </span><span style="color:#79B8FF">0.000001</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> cookTorranceNumerator </span><span style="color:#F97583">/</span><span style="color:#E1E4E8"> cookTorranceDenominator;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
</details>
<h5 id="ggx--throwbridge-reitz-normal-distribution-function">GGX / Throwbridge-Reitz Normal Distribution Function</h5>
<p>The GGX/Trowbridge-Reitz NDF models surface microfacet distribution, controlling highlight shape and roughness, making specular reflections appear more realistic in rendering.</p>
<span>
$$
\alpha = \text{roughness}^2
$$
</span>
<span>
$$
D_{\text{throwbridge-reitz}} = \frac{\alpha^2}{\pi((N \cdot H)^2(\alpha^2 - 1) + 1)^2}
$$
</span>
<h5 id="schlick-beckmann-geometry-shadowing-function">Schlick-Beckmann Geometry Shadowing Function</h5>
<p>This approximates light occlusion on rough surfaces, reducing reflection based on viewing angle and surface roughness for realistic shading.</p>
<p>In this case ( x ) will represent a dot product.</p>
<span>
$$
G_{\text{schlick-beckmann}} = \frac{(N \cdot X)}{(N \cdot X)(1-k)+k}
$$
</span>
<span>
$$
\begin{cases}
k=\frac{\alpha}{2}, \\[2ex]
X = V\text{ or }L
\end{cases}
$$
</span>
<h5 id="smith-model">Smith Model</h5>
<p>The Smith model calculates geometric shadowing and masking for microfacet shading, improving realism by accounting for how surface roughness affects light reflection and visibility.</p>
<span>
$$
G_{\text{smith}} = G_1(L,N)G_1(V,N)
$$
</span>
<h3 id="supplementary-reading">Supplementary Reading</h3>
<ul>
<li><a href="https://learnopengl.com/PBR/Theory">LearnOpenGL - PBR</a></li>
<li><a href="https://youtu.be/XK_p2MxGBQs?si=j7OM494e4z_DSvuc">OGLDEV - PBR</a></li>
<li><a href="http://blog.wolfire.com/2015/10/Physically-based-rendering">Wolfire Games</a></li>
</ul>  </article> </main> <footer> <hr> <p class="text-center text-mutes">Made with <span id="with-love">❤️</span> in Montréal.</p> </footer>  <script src="/gpr300-sokol/sugar.js"></script> </body> </html> 